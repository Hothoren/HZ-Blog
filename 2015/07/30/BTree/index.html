<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>B树——思路、及C语言代码的实现 | Hothoren的博客V0.09</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="0. 序   本人现读本科大二，这学期学习数据结构，老师为我们的期末作业布置一道任选题，而我一直以来都有听说B树是一棵挺神奇的树，所以我选择了它，当然更重要的原因是因为B树的难度最高，我喜欢做有挑战性的工作。同时，我听我基友说他热衷于将自己所学所想分享到博客园上，故才有了这样一篇文章。希望我能够在写博客的同时学习到更多东西，同时也能帮助到其他遇到或者即将遇到雷同问题的初学者们。
1. 关于B树">
<meta property="og:type" content="article">
<meta property="og:title" content="B树——思路、及C语言代码的实现">
<meta property="og:url" content="http://Hothoren.github.io/2015/07/30/BTree/index.html">
<meta property="og:site_name" content="Hothoren的博客V0.09">
<meta property="og:description" content="0. 序   本人现读本科大二，这学期学习数据结构，老师为我们的期末作业布置一道任选题，而我一直以来都有听说B树是一棵挺神奇的树，所以我选择了它，当然更重要的原因是因为B树的难度最高，我喜欢做有挑战性的工作。同时，我听我基友说他热衷于将自己所学所想分享到博客园上，故才有了这样一篇文章。希望我能够在写博客的同时学习到更多东西，同时也能帮助到其他遇到或者即将遇到雷同问题的初学者们。
1. 关于B树">
<meta property="og:image" content="http://images0.cnblogs.com/blog2015/760811/201507/130027377834221.png">
<meta property="og:image" content="http://images0.cnblogs.com/blog2015/760811/201507/162342587668724.png">
<meta property="og:image" content="http://images0.cnblogs.com/blog2015/760811/201507/162343115168029.png">
<meta property="og:updated_time" content="2015-07-30T09:18:36.200Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="B树——思路、及C语言代码的实现">
<meta name="twitter:description" content="0. 序   本人现读本科大二，这学期学习数据结构，老师为我们的期末作业布置一道任选题，而我一直以来都有听说B树是一棵挺神奇的树，所以我选择了它，当然更重要的原因是因为B树的难度最高，我喜欢做有挑战性的工作。同时，我听我基友说他热衷于将自己所学所想分享到博客园上，故才有了这样一篇文章。希望我能够在写博客的同时学习到更多东西，同时也能帮助到其他遇到或者即将遇到雷同问题的初学者们。
1. 关于B树">
  
    <link rel="alternative" href="/atom.xml" title="Hothoren的博客V0.09" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css" type="text/css">
</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="https://raw.githubusercontent.com/Hothoren/BlogSource/master/IMG/ME.jpg" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">Hothoren</a></h1>
		</hgroup>

		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						<div class="icon-wrap icon-link hide" data-idx="2">
							<div class="loopback_l"></div>
							<div class="loopback_r"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						<li>友情链接</li>
						
						
						<li>关于我</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/Hothoren" title="github">github</a>
					        
								<a class="weibo" target="_blank" href="http://weibo.com/u/2617018210" title="weibo">weibo</a>
					        
								<a class="zhihu" target="_blank" href="/#" title="zhihu">zhihu</a>
					        
								<a class="mail" target="_blank" href="/" title="mail">mail</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/想到什么写什么/" style="font-size: 10px;">想到什么写什么</a> <a href="/tags/数据结构/" style="font-size: 10px;">数据结构</a>
					</div>
				</section>
				
				
				
				<section class="switch-part switch-part3">
					<div id="js-friends">
					
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://qg-kkk.github.io/">奥巴马的博客</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://www.cnblogs.com/QG-Hothoren/">卡卡的美丽传说</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">本泽马的博客</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">吉格斯的博客</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">习大大大不同</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">托蒂的博客</a>
			        
			        </div>
				</section>
				

				
				
				<section class="switch-part switch-part4">
				
					<div id="js-aboutme">我是谁，我从哪里来，我到哪里去？我就是我，是颜色不一样的吃货…</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">Hothoren</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img lazy-src="https://raw.githubusercontent.com/Hothoren/BlogSource/master/IMG/ME.jpg" class="js-avatar">
			</div>
			<hgroup>
			  <h1 class="header-author">Hothoren</h1>
			</hgroup>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/Hothoren" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="http://weibo.com/u/2617018210" title="weibo">weibo</a>
			        
						<a class="zhihu" target="_blank" href="/#" title="zhihu">zhihu</a>
			        
						<a class="mail" target="_blank" href="/" title="mail">mail</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>
      <div class="body-wrap"><article id="post-BTree" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/07/30/BTree/" class="article-date">
  	<time datetime="2015-07-30T08:55:20.000Z" itemprop="datePublished">2015-07-30</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      B树——思路、及C语言代码的实现
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/数据结构/">数据结构</a></li></ul>
	</div>

        

        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="0-_序">0. 序</h1><p>   本人现读本科大二，这学期学习数据结构，老师为我们的期末作业布置一道任选题，而我一直以来都有听说B树是一棵挺神奇的树，所以我选择了它，当然更重要的原因是因为B树的难度最高，我喜欢做有挑战性的工作。同时，我听我基友说他热衷于将自己所学所想分享到博客园上，故才有了这样一篇文章。希望我能够在写博客的同时学习到更多东西，同时也能帮助到其他遇到或者即将遇到雷同问题的初学者们。</p>
<h1 id="1-_关于B树">1. 关于B树</h1><p>   B树是一种称之为查找树的树，与之类似的有查找二叉树，平衡二叉树，除此之外，还有各种B树的兄弟姐妹B+树、B-树、B*树等，他们共同的特点就是都是按照一定的顺序规律存储的。B树的应用也是很广泛的，B树是几乎所有数据库的默认索引结构，也是用的最多的索引结构。B树是一种多叉树，根据其最多叉的数目可以直接称为M阶B树。根据算法导论上叙述，还可按B树每个节点最少的分支确定一棵B树的阶，但是这样的话B树的阶便必须为偶数。我个人是使用根据最大分支的数目确定B树的阶的。<br>   下图就是某一棵B树，每一个结点中都包含有数个数据元素，而同时一定会有数据元素的个数加一个的子树。<br><img src="http://images0.cnblogs.com/blog2015/760811/201507/130027377834221.png" alt=""><br>    一棵M阶B树或为空树，或为满足下列特性的M叉树：</p>
<pre><code>（<span class="number">1</span>）树中每个结点最多含有M棵子树；

（<span class="number">2</span>）若根结点不是叶子结点，则至少有<span class="number">2</span>棵子树；

（<span class="number">3</span>）除根结点之外的所有非终端结点至少有[m/<span class="number">2</span>]棵子树；

（<span class="number">4</span>）每个非终端结点中包含的信息keynum，ptr[<span class="number">0</span>],key[<span class="number">1</span>],ptr[<span class="number">1</span>],key[<span class="number">2</span>],ptr[<span class="number">2</span>],……key[keynum],ptr[keynum];

其中，key为关键字，且关键字按升序排序，ptr为指向子树的根结点指针
</code></pre><h1 id="2-_思路及实现">2. 思路及实现</h1><p>　　B树的接口主要是插入（包括空树插入一个元素）和删除操作，而插入和删除操作不可避免的都会用到查找操作，而查找的主要思路比较简单，主要是利用B树是一种排序树的原理，可以很快找到要插入位置或者要删除结点。这里的关键是注意返回内容包括查找结果所在结点，以及该元素所在位置，这是为了方便接下来的操作比较简单。</p>
<p>插入：</p>
<p>　　通过对B树进行遍历，找出要插入的结点以及结点位置，如果找到的key值在B树当中已经存在，则说明插入失败，否则，就可以进行插入操作。这里可以先不管是否超出M阶树的上限要求，因为我们在定义的时候会故意留下一个位置，可以存放多余的一个元素，插入之后，通过判断是否达到M阶树上限要求，再进行递归的分裂操作。<br>/<em>*</em></p>
<ul>
<li>@name           Status insertBTree(BTree &amp;T, Record e)</li>
<li>@description    插入实现元素的插入</li>
<li>@return         成功返回OK,如果存在则返回FALSE，否则返回ERROR</li>
<li>@notice<br><em>*</em>/<br>Status insertBTree(BTree &amp;T, Record e)<br>{<br> BTree p;<br> int index, temp;<br> Status find_flag;<br> if (NULL == T)//考虑B树为空树的情况<br> {<pre><code><span class="literal">T</span> = (BTree)malloc(BTLEN);
<span class="keyword">if</span> (<span class="literal">NULL</span> == <span class="literal">T</span>) <span class="keyword">return</span> OVERFLOW;
<span class="literal">T</span>-&gt;keynum = <span class="number">1</span>;
<span class="literal">T</span>-&gt;parent = <span class="literal">NULL</span>;
<span class="keyword">for</span> (index = <span class="number">0</span>;index &lt;= m; ++index)
{
    <span class="literal">T</span>-&gt;ptr[index] = <span class="literal">NULL</span>;
    <span class="literal">T</span>-&gt;key[index] = <span class="number">0</span>;
}
<span class="literal">T</span>-&gt;key[<span class="number">1</span>] = e.key;
<span class="keyword">return</span> OK;
</code></pre> }<br> find_flag = findBTree(T, p, temp, e.key);//寻找插入节点<br> if (find_flag == TRUE)<br> {<pre><code><span class="keyword">return</span> <span class="literal">FALSE</span><span class="comment">;</span>
</code></pre> }<br> if (find_flag == FALSE)<br> {                                //不管怎样先直接插入<pre><code>p-&gt;keynum++;
<span class="keyword">for</span> (index = p-&gt;keynum;index &gt; temp;--index)
{
    p-&gt;key[index] = p-&gt;key[index - <span class="number">1</span>];
    p-&gt;ptr[index] = p-&gt;ptr[index - <span class="number">1</span>];
}
p-&gt;ptr[temp] = <span class="keyword">NULL</span>;
p-&gt;key[temp] = e.key;
<span class="keyword">if</span> (p-&gt;keynum == m)      <span class="comment">//这种情况得分裂</span>
{
    splitBTree(p);
}
renewParent(T);
<span class="keyword">return</span> OK;
</code></pre> }<br> return ERROR;<br>}</li>
</ul>
<p>分裂：</p>
<p>　　分裂操作是插入操作过程中一个最重要的操作，因为这是处理“冲突”（即结点中的数据元素大于B树规则中要求的最大个数）的一个通用的处理方式，这种方式必须要对所有的情况都适用，而分裂是解决这一问题一个方法。当然这种方法只是考虑到效率，没有对兄弟可否借数据进行判断，但是另外一种方式比较麻烦，这里先不做讨论。</p>
<p>　　分裂的思路是让父亲结点先腾出一个位置（包括key和ptr）出来，然后在需要分裂的结点里面取中间的元素并且移动中间的元素key到父亲结点已经腾出来的key位置那里，然后把分裂出来的右部分接到腾出来的ptr那里。注意整个过程对左部分和右部分的都要改变元素的个数以及清空一些没用的空间。在往上分裂之后可能会造成一种情况，就是父亲结点也可能达到分裂的最大个数，所以，检查父亲结点是否需要分裂，需要的话，递归之。</p>
<p>/<em>*</em></p>
<ul>
<li>@name           status splitBTree(BTree T)</li>
<li>@description    递归实现分裂节点操作</li>
<li>@return         成功返回OK,否则返回ERROR</li>
<li><p>@notice<br><em>*</em>/<br>Status splitBTree(BTree T) //此时分裂的节点一定会是超出最大值的。<br>{<br> BTree t1, t2;<br> int index, index_1;<br> if (T-&gt;parent == NULL)<br> {</p>
<pre><code>t1 = (BTree)<span class="built_in">malloc</span>(BTLEN);
<span class="keyword">if</span> (<span class="literal">NULL</span> == t1) <span class="keyword">return</span> OVERFLOW;
t2 = (BTree)<span class="built_in">malloc</span>(BTLEN);
<span class="keyword">if</span> (<span class="literal">NULL</span> == t2) <span class="keyword">return</span> OVERFLOW;

t1-&gt;keynum = m / <span class="number">2</span>;
t2-&gt;keynum = m - (m / <span class="number">2</span>) - <span class="number">1</span>;
t1-&gt;parent = T;
t2-&gt;parent = T;
<span class="keyword">for</span> (index = <span class="number">0</span>;index &lt;= m; ++index)  <span class="comment">//先全部初始化</span>
{
    t1-&gt;ptr[index] = <span class="literal">NULL</span>;
    t1-&gt;key[index] = <span class="number">0</span>;
    t2-&gt;ptr[index] = <span class="literal">NULL</span>;
    t2-&gt;key[index] = <span class="number">0</span>;
}
<span class="keyword">for</span> (index = <span class="number">0</span>;index &lt;= m / <span class="number">2</span>; ++index)  <span class="comment">//初始化t1</span>
{
    t1-&gt;ptr[index] = T-&gt;ptr[index];
    t1-&gt;key[index] = T-&gt;key[index];
}
t2-&gt;ptr[<span class="number">0</span>] = T-&gt;ptr[(m / <span class="number">2</span>) + <span class="number">1</span>];
<span class="keyword">for</span> (index = (m / <span class="number">2</span>) + <span class="number">2</span>;index &lt;= m; ++index)  <span class="comment">//初始化t2</span>
{
    t2-&gt;ptr[index - ((m / <span class="number">2</span>) + <span class="number">1</span>)] = T-&gt;ptr[index];
    t2-&gt;key[index - ((m / <span class="number">2</span>) + <span class="number">1</span>)] = T-&gt;key[index];
}
T-&gt;keynum = <span class="number">1</span>;
T-&gt;ptr[<span class="number">0</span>] = t1;
T-&gt;ptr[<span class="number">1</span>] = t2;
T-&gt;key[<span class="number">1</span>] = T-&gt;key[m / <span class="number">2</span> + <span class="number">1</span>];
<span class="keyword">for</span> (index = <span class="number">2</span>;index &lt;= m; ++index)  <span class="comment">//初始化T</span>
{
    T-&gt;ptr[index] = <span class="literal">NULL</span>;
    T-&gt;key[index] = <span class="number">0</span>;
}
<span class="keyword">return</span> OK;
</code></pre><p> }</p>
</li>
</ul>
<p>删除：</p>
<p>　　B树元素的删除操作与插入操作类似，但是却要麻烦，因为得分两种情况处理。（1）寻找到存在这个元素，而且这个元素所在是叶子节点（即它的孩子为空），直接对其进行删除，之后再判断是否小于B树规则中要求的最小的子树个数。如果小于，那就调用合并函数。（2）如果寻找到的这个元素是非叶子节点的元素，通过寻找比该元素小的最大元素（该元素肯定为叶子节点），把该元素直接赋值给要删除的元素，再在叶子节点处进行（1）中的操作。</p>
<p>/<em>*</em></p>
<ul>
<li>@name           Status deleteBTreeRecord(BTree &amp;T, Record e)</li>
<li>@description    实现B树元素的删除</li>
<li>@return         成功返回OK,否则返回ERROR</li>
<li>@notice<br><em>*</em>/<br>Status deleteBTreeRecord(BTree &amp;T, Record e)<br>{<br> BTree p, q;<br> int num, temp, index;<br> Status find_flag;<br> if (T == NULL)<pre><code><span class="keyword">return</span> <span class="built_in">ERROR</span>;
</code></pre> find_flag = findBTree(T, p, temp, e.key);<br> if (find_flag == FALSE)<br> {<pre><code><span class="keyword">return</span> <span class="literal">FALSE</span><span class="comment">;</span>
</code></pre> }<br> if (find_flag == TRUE)<br> {<pre><code><span class="comment">//deleteBTreeBNode(p,temp);</span>
<span class="keyword">if</span> (p-&gt;ptr[temp] == <span class="keyword">NULL</span>)                <span class="comment">//如果是叶子节点的话</span>
{
    <span class="keyword">for</span> (index = temp;index &lt;= p-&gt;keynum;++index)
    {
        p-&gt;key[index] = p-&gt;key[index + <span class="number">1</span>];
        p-&gt;ptr[index] = p-&gt;ptr[index + <span class="number">1</span>];
    }
    p-&gt;keynum--;
    <span class="keyword">if</span> (p-&gt;keynum == (m + <span class="number">1</span>) / <span class="number">2</span> - <span class="number">2</span>)
    {
        <span class="comment">//调用借兄弟的函数</span>
        <span class="keyword">if</span> (borrowBNode(p) == <span class="keyword">EMPTY</span>) T = <span class="keyword">NULL</span>;
        <span class="keyword">else</span> renewParent(T);
    }
    <span class="keyword">return</span> OK;
}
<span class="keyword">else</span>                                    <span class="comment">//不是叶子结点的话</span>
{
    <span class="comment">//遍历</span>
    findMax(p-&gt;ptr[temp - <span class="number">1</span>], q, num);<span class="comment">//返回的q一定会是叶子节点</span>
    p-&gt;key[temp] = q-&gt;key[num];
    q-&gt;key[num] = <span class="number">0</span>;
    q-&gt;keynum--;
    <span class="keyword">if</span> (q-&gt;keynum == (m + <span class="number">1</span>) / <span class="number">2</span> - <span class="number">2</span>)
    {
        <span class="comment">//调用借兄弟的函数</span>
        <span class="keyword">if</span> (borrowBNode(q) == <span class="keyword">EMPTY</span>) T = <span class="keyword">NULL</span>;
        <span class="keyword">else</span> renewParent(T);
    }
    <span class="keyword">return</span> OK;
}
<span class="keyword">return</span> OK;
</code></pre> }<br> return ERROR;<br>}</li>
</ul>
<p>合并:</p>
<p>　　在此先声明，因为一开始只考虑B树的阶为4的情况，后来改为使用宏定义阶M的数值，所以这段代码存在BUG，只支持阶为3或4的B树= =。</p>
<p>　　思路还是挺清晰的，首先先向兄弟结点借元素，如果兄弟能够借给你元素的话（即借了你之后并不会小于最少的分支），那么直接从兄弟那里取元素，否则，和兄弟合并。</p>
<p>　　合并其实是分裂反过来的情况，从父亲结点那里取出一个key值介于要合并的两个结点之间的元素，插入左部分最末尾处，同时右部分插到左部分后面，然后父亲结点元素依次往前挪。从而实现合并操作。之后，也必须对父亲结点进行判断是否小于最小的分支数，如果也小于，对父亲节点进行递归操作。</p>
<p>/<em>*</em></p>
<ul>
<li>@name           Status borrowBNode(BTree &amp;T)</li>
<li>@description    递归实现，向兄弟借元素，否则和兄弟合并</li>
<li>@return         成功返回OK,否则返回ERROR</li>
<li><p>@notice         这种情况应该是T为单元素结点<br><em>*</em>/<br>Status borrowBNode(BTree T)<br>{<br> int mynum, bronum, index;<br> BTree b = NULL, f = NULL;<br> if (T == NULL) return ERROR;<br> f = T-&gt;parent;<br> if (f == NULL)//考虑父亲结点不存在的情况<br> {</p>
<pre><code><span class="keyword">if</span> (T-&gt;keynum == <span class="number">0</span>)
{
    f = T-&gt;ptr[<span class="number">0</span>];
    <span class="keyword">if</span> (f == <span class="keyword">NULL</span>)
    {
        free(T);
        <span class="keyword">return</span> <span class="keyword">EMPTY</span>;
    }
    <span class="keyword">for</span> (index = <span class="number">0</span>;index &lt;= f-&gt;keynum;index++)
    {
        T-&gt;key[index] = f-&gt;key[index];
        T-&gt;ptr[index] = f-&gt;ptr[index];
    }
    T-&gt;keynum = f-&gt;keynum;
    free(f);
    renewParent(T);
}
<span class="keyword">return</span> OK;
</code></pre><p> }<br> mynum = whichSon(T);<br> if (mynum == 0)</p>
<pre><code><span class="keyword">bronum </span>= <span class="number">1</span><span class="comment">;</span>
</code></pre><p> else</p>
<pre><code><span class="keyword">bronum </span>= mynum - <span class="number">1</span><span class="comment">;</span>
</code></pre><p> b = f-&gt;ptr[bronum];<br> if (b-&gt;keynum == (m + 1) / 2 - 1) //如果兄弟帮不了你了<br> {</p>
<pre><code><span class="comment">//那么就和这个兄弟合体</span>
<span class="keyword">if</span> (bronum &lt; mynum)                    <span class="comment">//如果我不是第一个</span>
{
    b-&gt;keynum++;
    b-&gt;key[b-&gt;keynum] = f-&gt;key[mynum];
    b-&gt;ptr[b-&gt;keynum] = T-&gt;ptr[<span class="number">0</span>];
    <span class="keyword">for</span> (index = <span class="number">1</span>;index &lt;= T-&gt;keynum;index++)
    {
        b-&gt;key[index + b-&gt;keynum] = T-&gt;key[index];
        b-&gt;ptr[index + b-&gt;keynum] = T-&gt;ptr[index];
        b-&gt;keynum++;
    }
    free(T);
    <span class="keyword">for</span> (index = mynum;index &lt;= f-&gt;keynum;index++)
    {
        f-&gt;key[index] = f-&gt;key[index + <span class="number">1</span>];
        f-&gt;ptr[index] = f-&gt;ptr[index + <span class="number">1</span>];
    }
    f-&gt;keynum--;
}
<span class="keyword">else</span>
{
    T-&gt;keynum++;
    T-&gt;key[T-&gt;keynum] = f-&gt;key[bronum];
    T-&gt;ptr[T-&gt;keynum] = b-&gt;ptr[<span class="number">0</span>];
    <span class="keyword">for</span> (index = <span class="number">1</span>;index &lt;= b-&gt;keynum;index++)
    {
        T-&gt;key[index + T-&gt;keynum] = b-&gt;key[index];
        T-&gt;ptr[index + T-&gt;keynum] = b-&gt;ptr[index];
        T-&gt;keynum++;
    }
    free(b);
    <span class="keyword">for</span> (index = bronum;index &lt;= f-&gt;keynum;index++)
    {
        f-&gt;key[index] = f-&gt;key[index + <span class="number">1</span>];
        f-&gt;ptr[index] = f-&gt;ptr[index + <span class="number">1</span>];
    }
    f-&gt;keynum--;
}
renewParent(f);
<span class="keyword">if</span> (f-&gt;keynum == (m + <span class="number">1</span>) / <span class="number">2</span> - <span class="number">2</span>)
{
    <span class="comment">//调用借兄弟的函数</span>
    <span class="keyword">return</span> borrowBNode(f);
}
</code></pre><p> }<br> else//如果兄弟能够帮你<br> {</p>
<pre><code><span class="keyword">if</span> (bronum &lt; mynum)                    <span class="comment">//如果我不是第一个</span>
{
    <span class="keyword">for</span> (index = <span class="number">1</span>;index &lt;= T-&gt;keynum;index++)
    {
        T-&gt;key[index + <span class="number">1</span>] = T-&gt;key[index];
        T-&gt;ptr[index + <span class="number">1</span>] = T-&gt;ptr[index];
    }
    T-&gt;ptr[<span class="number">1</span>] = T-&gt;ptr[<span class="number">0</span>];
    T-&gt;key[<span class="number">1</span>] = f-&gt;key[mynum];
    T-&gt;ptr[<span class="number">0</span>] = b-&gt;ptr[b-&gt;keynum];
    T-&gt;keynum++;
    f-&gt;key[mynum] = b-&gt;key[b-&gt;keynum];
    b-&gt;key[b-&gt;keynum] = <span class="number">0</span>;
    b-&gt;ptr[b-&gt;keynum] = <span class="keyword">NULL</span>;
    b-&gt;keynum--;

}
<span class="keyword">else</span>                                    <span class="comment">//如果我是第一个</span>
{
    T-&gt;keynum++;
    T-&gt;key[T-&gt;keynum] = f-&gt;key[<span class="number">1</span>];
    T-&gt;ptr[T-&gt;keynum] = b-&gt;ptr[<span class="number">0</span>];
    f-&gt;key[<span class="number">1</span>] = b-&gt;key[<span class="number">1</span>];
    b-&gt;ptr[<span class="number">0</span>] = b-&gt;ptr[<span class="number">1</span>];
    <span class="keyword">for</span> (index = <span class="number">1</span>;index &lt;= b-&gt;keynum;index++)
    {
        b-&gt;key[index] = b-&gt;key[index + <span class="number">1</span>];
        b-&gt;ptr[index] = b-&gt;ptr[index + <span class="number">1</span>];
    }
    b-&gt;keynum--;
}
</code></pre><p> }<br> return OK;<br>}</p>
</li>
</ul>
<p>遍历，输出：</p>
<p>　　为了让B树更容易看，代码更容易调试，我同时还用队列写了个层次遍历，这个看看就好，实现起来挺麻烦的。而且可能代码实现也存在问题.</p>
<p>/<em>*</em></p>
<ul>
<li>@name           Status ergodic(BTree T, LinkList L, int newline, int sum)</li>
<li>@description    print需要用到的递归遍历程序</li>
<li>@return         成功返回OK</li>
<li>@notice         此处用到队列<br><em>*</em>/<br>Status ergodic(BTree T, LinkList L, int newline, int sum)<br>{<br> int index;<br> BTree p;<br> if (T != NULL)<br> {<pre><code><span class="built_in">printf</span>(<span class="string">"[ "</span>);
Enqueue_L(L, T-&gt;ptr[<span class="number">0</span>]);
<span class="keyword">for</span> (index = <span class="number">1</span>;index &lt;= T-&gt;keynum; index++)
{
    <span class="built_in">printf</span>(<span class="string">"%d "</span>, T-&gt;key[index]);
    Enqueue_L(L, T-&gt;ptr[index]);
}
sum += T-&gt;keynum + <span class="number">1</span>;
<span class="built_in">printf</span>(<span class="string">"]"</span>);
<span class="keyword">if</span> (newline == <span class="number">0</span>)
{
    <span class="built_in">printf</span>(<span class="string">"\n"</span>);
    newline = sum - <span class="number">1</span>;
    sum = <span class="number">0</span>;
}
<span class="keyword">else</span>
{
    --newline;
}
</code></pre> }<br> if (IfEmpty(L) == FALSE)<br> {<pre><code>Dequeue_L<span class="list">(<span class="keyword">L</span>, p)</span><span class="comment">;</span>
ergodic<span class="list">(<span class="keyword">p</span>, L, newline, sum)</span><span class="comment">;</span>
</code></pre> }<br> return OK;<br>}<br>/<em>*</em></li>
<li>@name           Status print(BTree T)</li>
<li>@description    层次遍历并分层输出B树</li>
<li>@return         成功返回OK</li>
<li>@notice<br><em>*</em>/<br>Status print(BTree T)<br>{<br> LinkList L;<br> if (T == NULL)<br> {<pre><code><span class="built_in">printf</span>(<span class="string">"[ ]\n"</span>);
<span class="built_in">return</span> OK;
</code></pre> }<br> InitQueue_L(L);<br> ergodic(T, L, 0, 0);<br> DestroyQueue(L);<br> return OK;<br>}<h1 id="3-_测试">3. 测试</h1></li>
</ul>
<p><img src="http://images0.cnblogs.com/blog2015/760811/201507/162342587668724.png" alt=""><br><img src="http://images0.cnblogs.com/blog2015/760811/201507/162343115168029.png" alt=""></p>
<h1 id="4-_总结">4. 总结</h1><p>　　以目前所掌握的知识，终于把B树做出来了，整个过程没有参考过其他人的代码，所以并不知道自己的一些思路是否得当，如有错误，多多包涵。在整个过程中，最难，卡的最久的也就是合并操作了，这块的代码也是乱得掉渣，以后有时间把他完善了。最后附上完整代码。</p>
<p>#define _CRT_SECURE_NO_WARNINGS</p>
<p>#include<stdio.h>         </stdio.h></p>
<p>#include<stdlib.h></stdlib.h></p>
<p>#include<time.h>  </time.h></p>
<p>#define BTREELENGTH 50</p>
<p>#define BTLEN (sizeof(BTNode))</p>
<p>#define MAXINT 100<br>typedef enum status<br>{<br>    TRUE,<br>    FALSE,<br>    OK,<br>    ERROR,<br>    OVERFLOW,<br>    EMPTY<br>}Status;<br>typedef int KeyType;</p>
<p>//<strong><strong><strong><strong><strong><strong><strong><strong>**</strong></strong></strong></strong></strong></strong></strong></strong>B树<strong><strong><strong><strong><strong><strong><strong><strong><strong><em>**</em></strong></strong></strong></strong></strong></strong></strong></strong></strong></p>
<p>#define  m  3   // B树的阶，此设为4<br>typedef struct<br>{<br>    KeyType  key;<br>    char     data;<br>} Record;<br>typedef struct BTNode<br>{<br>    int             keynum;        // 结点中关键字个数，即结点的大小<br>    struct BTNode  <em>parent;        // 指向双亲结点<br>    KeyType         key[m + 1];      // 关键字向量，0号单元未用<br>    struct BTNode  </em>ptr[m + 1];      // 子树指针向量<br>//  Record         <em>recptr[m + 1];   // 记录指针向量，0号单元未用<br>                                     //在此添加其他自定义数据<br>} BTNode, </em>BTree;                // B树结点和B树的类型<br>typedef struct<br>{<br>    BTNode  <em>pt;      // 指向找到的结点<br>    int      i;       // 1..m，在结点中的关键字序号<br>    int      tag;     // 1:查找成功，0:查找失败<br>} Result;           // 在B树的查找结果类型<br>//<strong><strong><strong><strong><strong><strong><strong><strong>**</strong></strong></strong></strong></strong></strong></strong></strong>B树<strong><strong><strong><strong><strong><strong><strong><strong><strong><em>*</em></strong></strong></strong></strong></strong></strong></strong></strong></strong></em></p>
<p>//<strong><strong><strong><strong><strong><strong><strong><strong>**</strong></strong></strong></strong></strong></strong></strong></strong>队列<strong><strong><strong><strong><strong><strong><strong><strong><strong><em>*</em></strong></strong></strong></strong></strong></strong></strong></strong></strong><br>typedef struct LNode {<br>    BTree data;     // 数据域<br>    struct LNode <em>next;     // 指针域<br>} LNode, </em>LinkList;<br>//<strong><strong><strong><strong><strong><strong><strong><strong>**</strong></strong></strong></strong></strong></strong></strong></strong>队列<strong><strong><strong><strong><strong><strong><strong><strong><strong><em>*</em></strong></strong></strong></strong></strong></strong></strong></strong></strong></p>
<p>/<em>*</em></p>
<ul>
<li>@name           Status InitQueue_L(LinkList &amp;L)</li>
<li>@description    初始化队列</li>
<li>@return         成功返回OK，开辟空间失败返回OVERFLOW</li>
<li>@notice<br><em>**/<br>Status InitQueue_L(LinkList &amp;L)<br>{ // 初始化一个只含头结点的空单链表L<br> if (NULL == (L = (LNode</em>)malloc(sizeof(LNode)))) // 生成新结点<pre><code><span class="keyword">return</span> OVERFLOW;
</code></pre> L-&gt;next = NULL;<br> return OK;<br>}<br>/<em>*</em></li>
<li>@name           LNode* MakeNode_L(BTree e)</li>
<li>@description    构造队列结点</li>
<li>@return         返回结点地址</li>
<li>@notice<br><em>**/<br>LNode</em> MakeNode_L(BTree e)<br>{ // 构造数据域为e的单链表结点<br> LNode <em>p;<br> p = (LNode</em>)malloc(sizeof(LNode)); // 分配结点空间<br> if (p != NULL)<br> {<pre><code><span class="title">p</span>-&gt;<span class="typedef"><span class="keyword">data</span> = e;</span>
<span class="title">p</span>-&gt;next = <span class="type">NULL</span>;
</code></pre> }<br> return p;<br>}<br>/<em>*</em></li>
<li>@name           Status Enqueue_L(LNode *p, BTree e)</li>
<li>@description    队列的入队</li>
<li>@return         成功返回OK，否则返回ERROR</li>
<li>@notice<br><em>**/<br>Status Enqueue_L(LNode </em>p, BTree e)<br>{ //在p结点之后插入q结点<br> if (NULL == p) return ERROR; // 参数不合理<br> while (p-&gt;next != NULL)<pre><code>p = p-&gt;<span class="keyword">next</span>;
</code></pre> p-&gt;next = MakeNode_L(e);         // 对应图4.11（b）的②，修改p结点的指针域<br> return OK;<br>}</li>
</ul>
<p>/<em>*</em></p>
<ul>
<li>@name           Status Dequeue_L(LNode *p, BTree &amp;e)</li>
<li>@description    队列的出队</li>
<li>@return         成功返回OK，否则返回ERROR</li>
<li>@notice<br><em>**/<br>Status Dequeue_L(LNode </em>p, BTree &amp;e)<br>{<br> // 删除p结点的直接后继结点并用参数e返回被删结点的值<br> LNode *q;<br> if (NULL == p || NULL == p-&gt;next) return ERROR; // 删除位置不合理<br> q = p-&gt;next;<br> p-&gt;next = q-&gt;next; // 修改被删结点q的指针域<br> e = q-&gt;data;<br> free(q); // 释放结点q<br> return OK;<br>}</li>
</ul>
<p>/<em>*</em></p>
<ul>
<li>@name           void DestroyQueue(LinkList L)</li>
<li>@description    队列的销毁</li>
<li>@return         无返回</li>
<li>@notice<br><em>*</em>/<br>void DestroyQueue(LinkList L)<br>{<br> // 销毁整个链表<br> LinkList p;<br> if (L != NULL)<br> {<pre><code>p = L<span class="comment">;</span>
L = L-&gt;next<span class="comment">;</span>
free(p)<span class="comment">;</span>
DestroyQueue(L)<span class="comment">;</span>
</code></pre> }<br>}<br>/<em>*</em></li>
<li>@name           Status  IfEmpty(LinkList L)</li>
<li>@description    判断队列是否为空</li>
<li>@return         空返回TRUE，不空返回FALSE，否则返回ERROR</li>
<li>@notice<br><strong><em>/<br>Status  IfEmpty(LinkList L)<br>{<br> if (L == NULL) return ERROR;<br> if (L-&gt;next == NULL) return TRUE;<br> return FALSE;<br>}<br>/</em></strong></li>
<li>@name           Status ergodic(BTree T, LinkList L, int newline, int sum)</li>
<li>@description    print需要用到的递归遍历程序</li>
<li>@return         成功返回OK</li>
<li>@notice         此处用到队列<br><em>*</em>/<br>Status ergodic(BTree T, LinkList L, int newline, int sum)<br>{<br> int index;<br> BTree p;<br> if (T != NULL)<br> {<pre><code><span class="built_in">printf</span>(<span class="string">"[ "</span>);
Enqueue_L(L, T-&gt;ptr[<span class="number">0</span>]);
<span class="keyword">for</span> (index = <span class="number">1</span>;index &lt;= T-&gt;keynum; index++)
{
    <span class="built_in">printf</span>(<span class="string">"%d "</span>, T-&gt;key[index]);
    Enqueue_L(L, T-&gt;ptr[index]);
}
sum += T-&gt;keynum + <span class="number">1</span>;
<span class="built_in">printf</span>(<span class="string">"]"</span>);
<span class="keyword">if</span> (newline == <span class="number">0</span>)
{
    <span class="built_in">printf</span>(<span class="string">"\n"</span>);
    newline = sum - <span class="number">1</span>;
    sum = <span class="number">0</span>;
}
<span class="keyword">else</span>
{
    --newline;
}
</code></pre> }<br> if (IfEmpty(L) == FALSE)<br> {<pre><code>Dequeue_L<span class="list">(<span class="keyword">L</span>, p)</span><span class="comment">;</span>
ergodic<span class="list">(<span class="keyword">p</span>, L, newline, sum)</span><span class="comment">;</span>
</code></pre> }<br> return OK;<br>}<br>/<em>*</em></li>
<li>@name           Status print(BTree T)</li>
<li>@description    层次遍历并分层输出B树</li>
<li>@return         成功返回OK</li>
<li>@notice<br><em>*</em>/<br>Status print(BTree T)<br>{<br> LinkList L;<br> if (T == NULL)<br> {<pre><code><span class="built_in">printf</span>(<span class="string">"[ ]\n"</span>);
<span class="built_in">return</span> OK;
</code></pre> }<br> InitQueue_L(L);<br> ergodic(T, L, 0, 0);<br> DestroyQueue(L);<br> return OK;<br>}</li>
</ul>
<p>/<em>*</em></p>
<ul>
<li>@name           Status findMax(BTree T, BTree &amp;p,int ans)</li>
<li>@description    寻找最大关键字的结点,T为要寻找的树，p为返回的节点,ans为第几个</li>
<li>@return         成功返回OK,否则返回ERROR</li>
<li>@notice<br><em>*</em>/<br>Status findMax(BTree T, BTree &amp;p, int &amp;ans)<br>{<br> if (T == NULL)<pre><code><span class="keyword">return</span> <span class="built_in">ERROR</span>;
</code></pre> p = T;<br> while (p-&gt;ptr[p-&gt;keynum] != NULL)<br> {<pre><code>p = p-&gt;ptr[p-&gt;keynum];
</code></pre> }<br> ans = p-&gt;keynum;<br> return OK;<br>}<br>/<em>*</em></li>
<li>@name           Status findMin(BTree T, BTree &amp;p,int ans)</li>
<li>@description    寻找最小关键字的结点,T为要寻找的树，p为返回的节点,ans为第几个</li>
<li>@return         成功返回OK,否则返回ERROR</li>
<li>@notice<br><strong><em>/<br>/</em></strong></li>
<li>@name           Status findBTree(BTree T, BTree &amp;p, int &amp;ans, KeyType k)</li>
<li>@description    寻找 ,T为要寻找的树，p为返回的节点，ans为第几个元素，k为要找的值</li>
<li>@return         成功返回OK,否则返回ERROR</li>
<li><p>@notice<br><em>*</em>/<br>Status findBTree(BTree T, BTree &amp;p, int &amp;ans, KeyType k)<br>{<br> BTree q;<br> int index = 1;<br> KeyType  keynow;<br> if (T == NULL)</p>
<pre><code><span class="keyword">return</span> <span class="built_in">ERROR</span>;
</code></pre><p> q = T;<br> keynow = T-&gt;key[1];<br> while (q != NULL)                 //深度的遍历<br> {</p>
<pre><code>index = <span class="number">1</span>;
keynow = q-&gt;key[index];
<span class="keyword">while</span> (index &lt;= q-&gt;keynum) <span class="comment">//节点内对各真值进行遍历</span>
{
    <span class="keyword">if</span> (k == keynow)           <span class="comment">//找到元素</span>
    {
        p = q;
        ans = index;
        <span class="keyword">return</span> <span class="keyword">TRUE</span>;
    }
    <span class="keyword">if</span> (k &gt; keynow)
    {
        <span class="keyword">if</span> (index == q-&gt;keynum)
        {
            <span class="keyword">if</span> (q-&gt;ptr[index] == <span class="keyword">NULL</span>)
            {
                p = q;
                ans = q-&gt;keynum + <span class="number">1</span>;
                <span class="keyword">return</span> <span class="keyword">FALSE</span>;
            }
            q = q-&gt;ptr[index];
            <span class="keyword">break</span>;
        }
        ++index;
        keynow = q-&gt;key[index];
        <span class="keyword">continue</span>;
    }
    <span class="keyword">if</span> (k &lt; keynow)
    {
        <span class="keyword">if</span> (q-&gt;ptr[index - <span class="number">1</span>] == <span class="keyword">NULL</span>)
        {
            p = q;
            ans = index;
            <span class="keyword">return</span> <span class="keyword">FALSE</span>;
        }
        q = q-&gt;ptr[index - <span class="number">1</span>];
        <span class="keyword">break</span>;
    }
}
</code></pre><p> }</p>
<p> return ERROR;<br>}<br>/<em>*</em></p>
</li>
<li>@name           Status renewParent(BTree p)</li>
<li>@description    告诉孩子们亲身爸爸是谁</li>
<li>@return         成功返回OK,否则返回ERROR</li>
<li>@notice<br><em>*</em>/<br>Status renewParent(BTree p)<br>{<br> int index;<br> if (p == NULL) return ERROR;<br> for (index = 0;index &lt;= p-&gt;keynum;++index)<br> {<pre><code><span class="keyword">if</span> (p-&gt;ptr[index] != <span class="keyword">NULL</span>)
{
    p-&gt;ptr[index]-&gt;parent = p;
    renewParent(p-&gt;ptr[index]);
}
</code></pre> }<br> return OK;<br>}<br>/<em>*</em></li>
<li>@name           int whichSon(BTree T)</li>
<li>@description    找出是父亲的第几个孩子</li>
<li>@return         成功返回第几个孩子,否则返回-1</li>
<li>@notice<br><em>*</em>/<br>int whichSon(BTree T)<br>{<br> int index = -1;<br> if (T == NULL) return -1;<br> for (index = 0;index &lt;= T-&gt;parent-&gt;keynum;++index) //找出是父亲的第几个孩子<br> {<pre><code><span class="keyword">if</span> (T-&gt;parent-&gt;<span class="keyword">ptr</span>[<span class="built_in">index</span>] == T) <span class="keyword">return</span> <span class="built_in">index</span>;
</code></pre> }<br> return -1;<br>}<br>/<em>*</em></li>
<li>@name           status splitBTree(BTree T)</li>
<li>@description    递归实现分裂节点操作</li>
<li>@return         成功返回OK,否则返回ERROR</li>
<li><p>@notice<br><em>*</em>/<br>Status splitBTree(BTree T) //此时分裂的节点一定会是超出最大值的。<br>{<br> BTree t1, t2;<br> int index, index_1;<br> if (T-&gt;parent == NULL)<br> {</p>
<pre><code>t1 = (BTree)<span class="built_in">malloc</span>(BTLEN);
<span class="keyword">if</span> (<span class="literal">NULL</span> == t1) <span class="keyword">return</span> OVERFLOW;
t2 = (BTree)<span class="built_in">malloc</span>(BTLEN);
<span class="keyword">if</span> (<span class="literal">NULL</span> == t2) <span class="keyword">return</span> OVERFLOW;

t1-&gt;keynum = m / <span class="number">2</span>;
t2-&gt;keynum = m - (m / <span class="number">2</span>) - <span class="number">1</span>;
t1-&gt;parent = T;
t2-&gt;parent = T;
<span class="keyword">for</span> (index = <span class="number">0</span>;index &lt;= m; ++index)  <span class="comment">//先全部初始化</span>
{
    t1-&gt;ptr[index] = <span class="literal">NULL</span>;
    t1-&gt;key[index] = <span class="number">0</span>;
    t2-&gt;ptr[index] = <span class="literal">NULL</span>;
    t2-&gt;key[index] = <span class="number">0</span>;
}
<span class="keyword">for</span> (index = <span class="number">0</span>;index &lt;= m / <span class="number">2</span>; ++index)  <span class="comment">//初始化t1</span>
{
    t1-&gt;ptr[index] = T-&gt;ptr[index];
    t1-&gt;key[index] = T-&gt;key[index];
}
t2-&gt;ptr[<span class="number">0</span>] = T-&gt;ptr[(m / <span class="number">2</span>) + <span class="number">1</span>];
<span class="keyword">for</span> (index = (m / <span class="number">2</span>) + <span class="number">2</span>;index &lt;= m; ++index)  <span class="comment">//初始化t2</span>
{
    t2-&gt;ptr[index - ((m / <span class="number">2</span>) + <span class="number">1</span>)] = T-&gt;ptr[index];
    t2-&gt;key[index - ((m / <span class="number">2</span>) + <span class="number">1</span>)] = T-&gt;key[index];
}
T-&gt;keynum = <span class="number">1</span>;
T-&gt;ptr[<span class="number">0</span>] = t1;
T-&gt;ptr[<span class="number">1</span>] = t2;
T-&gt;key[<span class="number">1</span>] = T-&gt;key[m / <span class="number">2</span> + <span class="number">1</span>];
<span class="keyword">for</span> (index = <span class="number">2</span>;index &lt;= m; ++index)  <span class="comment">//初始化T</span>
{
    T-&gt;ptr[index] = <span class="literal">NULL</span>;
    T-&gt;key[index] = <span class="number">0</span>;
}
<span class="keyword">return</span> OK;
</code></pre><p> }</p>
<p> index = whichSon(T);<br> for (index_1 = T-&gt;parent-&gt;keynum;index_1 &gt; index;–index_1) //腾出父亲的位置<br> {</p>
<pre><code><span class="type">T</span>-&gt;parent-&gt;ptr[index_1 + <span class="number">1</span>] = <span class="type">T</span>-&gt;parent-&gt;ptr[index_1];
<span class="type">T</span>-&gt;parent-&gt;key[index_1 + <span class="number">1</span>] = <span class="type">T</span>-&gt;parent-&gt;key[index_1];
</code></pre><p> }<br> T-&gt;parent-&gt;keynum++;<br> T-&gt;parent-&gt;key[index + 1] = T-&gt;key[m / 2 + 1];<br> t2 = T-&gt;parent-&gt;ptr[index + 1] = (BTree)malloc(BTLEN);<br> if (NULL == t2) return OVERFLOW;<br> for (index = 0;index &lt;= m; ++index)  //先全部初始化<br> {</p>
<pre><code>t2-&gt;ptr[index] = <span class="keyword">NULL</span>;
t2-&gt;key[index] = <span class="number">0</span>;
</code></pre><p> }<br> t2-&gt;keynum = m - (m / 2) - 1;<br> t2-&gt;parent = T-&gt;parent;<br> t2-&gt;ptr[0] = T-&gt;ptr[(m / 2) + 1];<br> for (index = (m / 2) + 2;index &lt;= m; ++index)  //初始化t2<br> {</p>
<pre><code>t2-&gt;<span class="keyword">ptr</span>[<span class="built_in">index</span> - ((<span class="keyword">m</span> / <span class="number">2</span>) + <span class="number">1</span>)] = T-&gt;<span class="keyword">ptr</span>[<span class="built_in">index</span>];
t2-&gt;key[<span class="built_in">index</span> - ((<span class="keyword">m</span> / <span class="number">2</span>) + <span class="number">1</span>)] = T-&gt;key[<span class="built_in">index</span>];
</code></pre><p> }<br> T-&gt;keynum = m / 2;<br> for (index = (m / 2) + 1;index &lt;= m; ++index)  //初始化t2<br> {</p>
<pre><code>T-&gt;ptr[index] = <span class="keyword">NULL</span>;
T-&gt;key[index] = <span class="number">0</span>;
</code></pre><p> }<br> if (T-&gt;parent-&gt;keynum == m)<br> {</p>
<pre><code>splitBTree(T<span class="subst">-&gt;</span><span class="keyword">parent</span>);
</code></pre><p> }<br> return OK;<br>}<br>/<em>*</em></p>
</li>
<li>@name           Status insertBTree(BTree &amp;T, Record e)</li>
<li>@description    插入实现元素的插入</li>
<li>@return         成功返回OK,如果存在则返回FALSE，否则返回ERROR</li>
<li>@notice<br><em>*</em>/<br>Status insertBTree(BTree &amp;T, Record e)<br>{<br> BTree p;<br> int index, temp;<br> Status find_flag;<br> if (NULL == T)<br> {<pre><code><span class="literal">T</span> = (BTree)malloc(BTLEN);
<span class="keyword">if</span> (<span class="literal">NULL</span> == <span class="literal">T</span>) <span class="keyword">return</span> OVERFLOW;
<span class="literal">T</span>-&gt;keynum = <span class="number">1</span>;
<span class="literal">T</span>-&gt;parent = <span class="literal">NULL</span>;
<span class="keyword">for</span> (index = <span class="number">0</span>;index &lt;= m; ++index)
{
    <span class="literal">T</span>-&gt;ptr[index] = <span class="literal">NULL</span>;
    <span class="literal">T</span>-&gt;key[index] = <span class="number">0</span>;
}
<span class="literal">T</span>-&gt;key[<span class="number">1</span>] = e.key;
<span class="keyword">return</span> OK;
</code></pre> }<br> find_flag = findBTree(T, p, temp, e.key);<br> if (find_flag == TRUE)<br> {<pre><code><span class="keyword">return</span> <span class="literal">FALSE</span><span class="comment">;</span>
</code></pre> }<br> if (find_flag == FALSE)<br> {                                //不管怎样先直接插入<pre><code>p-&gt;keynum++;
<span class="keyword">for</span> (index = p-&gt;keynum;index &gt; temp;--index)
{
    p-&gt;key[index] = p-&gt;key[index - <span class="number">1</span>];
    p-&gt;ptr[index] = p-&gt;ptr[index - <span class="number">1</span>];
}
p-&gt;ptr[temp] = <span class="keyword">NULL</span>;
p-&gt;key[temp] = e.key;
<span class="keyword">if</span> (p-&gt;keynum == m)      <span class="comment">//这种情况得分裂</span>
{
    splitBTree(p);
}
renewParent(T);
<span class="keyword">return</span> OK;
</code></pre> }<br> return ERROR;<br>}<br>/<em>*</em></li>
<li>@name           Status borrowBNode(BTree &amp;T)</li>
<li>@description    递归实现，向兄弟借元素，否则和兄弟合并</li>
<li>@return         成功返回OK,否则返回ERROR</li>
<li><p>@notice         这种情况应该是T为单元素结点<br><em>*</em>/<br>Status borrowBNode(BTree T)<br>{<br> int mynum, bronum, index;<br> BTree b = NULL, f = NULL;<br> if (T == NULL) return ERROR;<br> f = T-&gt;parent;<br> if (f == NULL)//考虑父亲结点不存在的情况<br> {</p>
<pre><code><span class="keyword">if</span> (T-&gt;keynum == <span class="number">0</span>)
{
    f = T-&gt;ptr[<span class="number">0</span>];
    <span class="keyword">if</span> (f == <span class="keyword">NULL</span>)
    {
        free(T);
        <span class="keyword">return</span> <span class="keyword">EMPTY</span>;
    }
    <span class="keyword">for</span> (index = <span class="number">0</span>;index &lt;= f-&gt;keynum;index++)
    {
        T-&gt;key[index] = f-&gt;key[index];
        T-&gt;ptr[index] = f-&gt;ptr[index];
    }
    T-&gt;keynum = f-&gt;keynum;
    free(f);
    renewParent(T);
}
<span class="keyword">return</span> OK;
</code></pre><p> }<br> mynum = whichSon(T);<br> if (mynum == 0)</p>
<pre><code><span class="keyword">bronum </span>= <span class="number">1</span><span class="comment">;</span>
</code></pre><p> else</p>
<pre><code><span class="keyword">bronum </span>= mynum - <span class="number">1</span><span class="comment">;</span>
</code></pre><p> b = f-&gt;ptr[bronum];<br> if (b-&gt;keynum == (m + 1) / 2 - 1) //如果兄弟帮不了你了<br> {</p>
<pre><code><span class="comment">//那么就和这个兄弟合体</span>
<span class="keyword">if</span> (bronum &lt; mynum)                    <span class="comment">//如果我不是第一个</span>
{
    b-&gt;keynum++;
    b-&gt;key[b-&gt;keynum] = f-&gt;key[mynum];
    b-&gt;ptr[b-&gt;keynum] = T-&gt;ptr[<span class="number">0</span>];
    <span class="keyword">for</span> (index = <span class="number">1</span>;index &lt;= T-&gt;keynum;index++)
    {
        b-&gt;key[index + b-&gt;keynum] = T-&gt;key[index];
        b-&gt;ptr[index + b-&gt;keynum] = T-&gt;ptr[index];
        b-&gt;keynum++;
    }
    free(T);
    <span class="keyword">for</span> (index = mynum;index &lt;= f-&gt;keynum;index++)
    {
        f-&gt;key[index] = f-&gt;key[index + <span class="number">1</span>];
        f-&gt;ptr[index] = f-&gt;ptr[index + <span class="number">1</span>];
    }
    f-&gt;keynum--;
}
<span class="keyword">else</span>
{
    T-&gt;keynum++;
    T-&gt;key[T-&gt;keynum] = f-&gt;key[bronum];
    T-&gt;ptr[T-&gt;keynum] = b-&gt;ptr[<span class="number">0</span>];
    <span class="keyword">for</span> (index = <span class="number">1</span>;index &lt;= b-&gt;keynum;index++)
    {
        T-&gt;key[index + T-&gt;keynum] = b-&gt;key[index];
        T-&gt;ptr[index + T-&gt;keynum] = b-&gt;ptr[index];
        T-&gt;keynum++;
    }
    free(b);
    <span class="keyword">for</span> (index = bronum;index &lt;= f-&gt;keynum;index++)
    {
        f-&gt;key[index] = f-&gt;key[index + <span class="number">1</span>];
        f-&gt;ptr[index] = f-&gt;ptr[index + <span class="number">1</span>];
    }
    f-&gt;keynum--;
}
renewParent(f);
<span class="keyword">if</span> (f-&gt;keynum == (m + <span class="number">1</span>) / <span class="number">2</span> - <span class="number">2</span>)
{
    <span class="comment">//调用借兄弟的函数</span>
    <span class="keyword">return</span> borrowBNode(f);
}
</code></pre><p> }<br> else//如果兄弟能够帮你<br> {</p>
<pre><code><span class="keyword">if</span> (bronum &lt; mynum)                    <span class="comment">//如果我不是第一个</span>
{
    <span class="keyword">for</span> (index = <span class="number">1</span>;index &lt;= T-&gt;keynum;index++)
    {
        T-&gt;key[index + <span class="number">1</span>] = T-&gt;key[index];
        T-&gt;ptr[index + <span class="number">1</span>] = T-&gt;ptr[index];
    }
    T-&gt;ptr[<span class="number">1</span>] = T-&gt;ptr[<span class="number">0</span>];
    T-&gt;key[<span class="number">1</span>] = f-&gt;key[mynum];
    T-&gt;ptr[<span class="number">0</span>] = b-&gt;ptr[b-&gt;keynum];
    T-&gt;keynum++;
    f-&gt;key[mynum] = b-&gt;key[b-&gt;keynum];
    b-&gt;key[b-&gt;keynum] = <span class="number">0</span>;
    b-&gt;ptr[b-&gt;keynum] = <span class="keyword">NULL</span>;
    b-&gt;keynum--;

}
<span class="keyword">else</span>                                    <span class="comment">//如果我是第一个</span>
{
    T-&gt;keynum++;
    T-&gt;key[T-&gt;keynum] = f-&gt;key[<span class="number">1</span>];
    T-&gt;ptr[T-&gt;keynum] = b-&gt;ptr[<span class="number">0</span>];
    f-&gt;key[<span class="number">1</span>] = b-&gt;key[<span class="number">1</span>];
    b-&gt;ptr[<span class="number">0</span>] = b-&gt;ptr[<span class="number">1</span>];
    <span class="keyword">for</span> (index = <span class="number">1</span>;index &lt;= b-&gt;keynum;index++)
    {
        b-&gt;key[index] = b-&gt;key[index + <span class="number">1</span>];
        b-&gt;ptr[index] = b-&gt;ptr[index + <span class="number">1</span>];
    }
    b-&gt;keynum--;
}
</code></pre><p> }<br> return OK;<br>}</p>
</li>
</ul>
<p>/<em>*</em></p>
<ul>
<li>@name           Status deleteBTreeRecord(BTree &amp;T, Record e)</li>
<li>@description    实现B树元素的删除</li>
<li>@return         成功返回OK,否则返回ERROR</li>
<li>@notice<br><em>*</em>/<br>Status deleteBTreeRecord(BTree &amp;T, Record e)<br>{<br> BTree p, q;<br> int num, temp, index;<br> Status find_flag;<br> if (T == NULL)<pre><code><span class="keyword">return</span> <span class="built_in">ERROR</span>;
</code></pre> find_flag = findBTree(T, p, temp, e.key);<br> if (find_flag == FALSE)<br> {<pre><code><span class="keyword">return</span> <span class="literal">FALSE</span><span class="comment">;</span>
</code></pre> }<br> if (find_flag == TRUE)<br> {<pre><code><span class="comment">//deleteBTreeBNode(p,temp);</span>
<span class="keyword">if</span> (p-&gt;ptr[temp] == <span class="keyword">NULL</span>)                <span class="comment">//如果是叶子节点的话</span>
{
    <span class="keyword">for</span> (index = temp;index &lt;= p-&gt;keynum;++index)
    {
        p-&gt;key[index] = p-&gt;key[index + <span class="number">1</span>];
        p-&gt;ptr[index] = p-&gt;ptr[index + <span class="number">1</span>];
    }
    p-&gt;keynum--;
    <span class="keyword">if</span> (p-&gt;keynum == (m + <span class="number">1</span>) / <span class="number">2</span> - <span class="number">2</span>)
    {
        <span class="comment">//调用借兄弟的函数</span>
        <span class="keyword">if</span> (borrowBNode(p) == <span class="keyword">EMPTY</span>) T = <span class="keyword">NULL</span>;
        <span class="keyword">else</span> renewParent(T);
    }
    <span class="keyword">return</span> OK;
}
<span class="keyword">else</span>                                    <span class="comment">//不是叶子结点的话</span>
{
    <span class="comment">//遍历</span>
    findMax(p-&gt;ptr[temp - <span class="number">1</span>], q, num);<span class="comment">//返回的q一定会是叶子节点</span>
    p-&gt;key[temp] = q-&gt;key[num];
    q-&gt;key[num] = <span class="number">0</span>;
    q-&gt;keynum--;
    <span class="keyword">if</span> (q-&gt;keynum == (m + <span class="number">1</span>) / <span class="number">2</span> - <span class="number">2</span>)
    {
        <span class="comment">//调用借兄弟的函数</span>
        <span class="keyword">if</span> (borrowBNode(q) == <span class="keyword">EMPTY</span>) T = <span class="keyword">NULL</span>;
        <span class="keyword">else</span> renewParent(T);
    }
    <span class="keyword">return</span> OK;
}
<span class="keyword">return</span> OK;
</code></pre> }<br> return ERROR;<br>}<br>/<em>*</em></li>
<li>@name           Status initBTree(BTree &amp;t)</li>
<li>@description    初始化一个空B树</li>
<li>@return         成功返回OK</li>
<li>@notice<br><strong><em>/<br>Status initBTree(BTree &amp;t)<br>{<br> t = NULL;<br> return OK;<br>}<br>/</em></strong></li>
<li>@name           Status test()</li>
<li>@description    针对数据结构实验做的测试函数</li>
<li>@return         成功返回OK</li>
<li>@notice<br><em>*</em>/<br>Status test()<br>{<br> // 测试代码<br> int n, i;<br> int arr[BTREELENGTH];<br> BTree a;<br> Record  d;<br> srand((unsigned)time(NULL));<br> n = rand() % BTREELENGTH;<br> //scanf(“%d”, &amp;n);                    //可以改为自己输入数据<br> printf(“B树的阶为:%d,插入次数为:%d\n”, m, n);<br> initBTree(a);<br> for (i = 0;i &lt; n;i++)<br> {<pre><code>d.key = <span class="keyword">rand</span>() % MAXINT;
<span class="regexp">//scanf</span>(<span class="string">"<span class="variable">%d</span>"</span>, &amp;d.key);            <span class="regexp">//</span>可以改为自己输入数据
arr[i] = d.key;
<span class="keyword">if</span> (insertBTree(a, d) == OK)
    <span class="keyword">printf</span>(<span class="string">"第<span class="variable">%d</span>次插入<span class="variable">%d</span>:\n"</span>, i + <span class="number">1</span>, d.key);
<span class="keyword">else</span>
    <span class="keyword">printf</span>(<span class="string">"第<span class="variable">%d</span>次插入<span class="variable">%d</span>不成功:\n"</span>, i + <span class="number">1</span>, d.key);
<span class="keyword">print</span>(a);
</code></pre> }<br> for (i = 0;i &lt; n;i++)<br> {<pre><code>d.key = arr[i];
<span class="keyword">if</span> (deleteBTreeRecord(a, d) == OK)
    <span class="keyword">printf</span>(<span class="string">"第<span class="variable">%d</span>次删除<span class="variable">%d</span>:\n"</span>, i + <span class="number">1</span>, d.key);
<span class="keyword">else</span>
    <span class="keyword">printf</span>(<span class="string">"第<span class="variable">%d</span>次删除<span class="variable">%d</span>不成功:\n"</span>, i + <span class="number">1</span>, d.key);
<span class="keyword">print</span>(a);
</code></pre> }<br> return OK;</li>
</ul>
<p>}<br>/<strong><em><br>主函数
</em></strong>/<br>int  main()<br>{<br>    test();<br>    return 0;<br>}</p>
<p>BTree</p>

      
    </div>
    
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2015/07/30/haha/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">哈哈</div>
      <strong class="article-nav-caption">></strong>
    </a>
  
</nav>

  
</article>


<div class="share">
	<!-- JiaThis Button BEGIN -->
	<div class="jiathis_style">
		<span class="jiathis_txt">分享到：</span>
		<a class="jiathis_button_tsina"></a>
		<a class="jiathis_button_cqq"></a>
		<a class="jiathis_button_douban"></a>
		<a class="jiathis_button_weixin"></a>
		<a class="jiathis_button_tumblr"></a>
		<a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jtico jtico_jiathis" target="_blank"></a>
	</div>
	<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js?uid=1405949716054953" charset="utf-8"></script>
	<!-- JiaThis Button END -->
</div>



<div class="duoshuo">
	<!-- 多说评论框 start -->
	<div class="ds-thread" data-thread-key="BTree" data-title="B树——思路、及C语言代码的实现" data-url="http://Hothoren.github.io/2015/07/30/BTree/"></div>
	<!-- 多说评论框 end -->
	<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
	<script type="text/javascript">
	var duoshuoQuery = {short_name:"Hothoren"};
	(function() {
		var ds = document.createElement('script');
		ds.type = 'text/javascript';ds.async = true;
		ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
		ds.charset = 'UTF-8';
		(document.getElementsByTagName('head')[0] 
		 || document.getElementsByTagName('body')[0]).appendChild(ds);
	})();
	</script>
	<!-- 多说公共JS代码 end -->
</div>




</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2015 Hothoren
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: false,
		isPost: true,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js" type="text/javascript"></script>
<script src="/js/main.js" type="text/javascript"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  </div>
</body>
</html>